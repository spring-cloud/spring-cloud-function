:branch: master

=== Microsoft Azure

The https://azure.microsoft.com[Azure] adapter bootstraps a Spring Cloud Function context and channels function calls from the Azure 
framework into the user functions, using Spring Boot configuration where necessary. Azure Functions has quite a unique, but 
invasive programming model, involving annotations in user code that are specific to the platform. The easiest way to use it with 
Spring Cloud is to extend a base class and write a method in it with the `@FunctionName` annotation which delegates to a base class method.


This project provides an adapter layer for a Spring Cloud Function application onto Azure.
You can write an app with a single `@Bean` of type `Function` and it will be deployable in Azure if you get the JAR file laid out right.

There is an `org.springframework.cloud.function.adapter.azure.FunctionInvoker` which you must extend, and provide the 
input and output types as annotated 
method parameters (enabling Azure to inspect the class and create JSON bindings). The base class has two useful 
methods (`handleRequest` and `handleOutput`) to which you can delegate the actual function call, so mostly the function will only ever have one line.

Example:

```java
public class FooHandler extends FunctionInvoker<Foo, Bar> {
	@FunctionName("uppercase")
	public Bar execute(@HttpTrigger(name = "req", methods = {HttpMethod.GET,
			HttpMethod.POST}, authLevel = AuthorizationLevel.ANONYMOUS) HttpRequestMessage<Optional<Foo>> request,
		ExecutionContext context) {
		return handleRequest(request.getBody().get(), context);
	}
}
```

This Azure handler will delegate to a `Function<Foo,Bar>` bean (or a `Function<Publisher<Foo>,Publisher<Bar>>`). Some Azure 
triggers (e.g. `@CosmosDBTrigger`) result in a input type of `List` and in that case you can bind to `List` in the Azure handler, 
or `String` (the raw JSON). The `List` input delegates to a `Function` with input type `Map<String,Object>`, or `Publisher` or `List` of 
the same type. The output of the `Function` can be a `List` (one-for-one) or a single value (aggregation), and the output binding in the 
Azure declaration should match.

If your app has more than one `@Bean` of type `Function` etc. then you can choose the one to use by configuring 
`function.name`. Or if you make the `@FunctionName` in the Azure handler method match the function name it should work that 
way (also for function apps with multiple functions). The functions are extracted from the Spring Cloud `FunctionCatalog` so the default 
function names are the same as the bean names.

==== Accessing Azure ExecutionContext

Some time there is a need to access the target execution context provided by Azure runtime in the form of `com.microsoft.azure.functions.ExecutionContext`.
For example one of such needs is logging, so it can appear in the Azure console.

For that purpose we propagate `ExecutionContext` as Message header under `executionContext` name, so all you need is access it 
is have your function accept a Message and access this header.

Spring Cloud Function will register `ExecutionContext` as bean in the Application context, so it could be injected into your function.
For example
```java
@Bean
public Function<Message<Foo>, Bar> uppercase() {
	return message -> {
		ExecutionContext targetContext = message.getHeaders().get("executionContext");
		targetContext.getLogger().info("Invoking 'uppercase' on " + foo.getValue());
		return new Bar(message.getPayload().getValue().toUpperCase());
	};
}
```
With Message you will also have access to additional Azure meta information as Message headers that come as part of your request.


==== Notes on JAR Layout

You don't need the Spring Cloud Function Web at runtime in Azure, so you can exclude this
before you create the JAR you deploy to Azure, but it won't be used if you include it, so
it doesn't hurt to leave it in. A function application on Azure is an archive generated by
 the Maven plugin. The function lives in the JAR file generated by this project.
 The sample creates it as an executable jar, using the thin layout, so that Azure can find
 the handler classes. If you prefer you can just use a regular flat JAR file.
 The dependencies should *not* be included.

==== Build file setup

In order to run Spring Cloud Function applications on Microsoft Azure, you can leverage the Maven
plugin offered by the cloud platform provider.

In order to use the adapter plugin for Maven, add the plugin dependency to your `pom.xml`
file:

[source,xml]
----
<dependencies>
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-function-adapter-azure</artifactId>
	</dependency>
</dependencies>
----

Then, configure the plugin. You will need to provide Azure-specific configuration for your
application, specifying the `resourceGroup`, `appName` and other optional properties, and
 add the `package` goal execution so that the `function.json` file required by Azure is
  generated for you. Full plugin documentation can be found in the https://github.com/microsoft/azure-maven-plugins[plugin repository].

[source,xml]
----
<plugin>
	<groupId>com.microsoft.azure</groupId>
	<artifactId>azure-functions-maven-plugin</artifactId>
	<configuration>
		<resourceGroup>${functionResourceGroup}</resourceGroup>
		<appName>${functionAppName}</appName>
	</configuration>
	<executions>
		<execution>
			<id>package-functions</id>
			<goals>
				<goal>package</goal>
			</goals>
		</execution>
	</executions>
</plugin>
----

You will also have to ensure that the files to be scanned by the plugin can be found in the
Azure functions staging directory (see the https://github.com/microsoft/azure-maven-plugins[plugin repository]
 for more details on the staging directory and it's default location).

You can find the entire sample `pom.xml` file for deploying Spring Cloud Function
applications to Microsoft Azure with Maven https://github.com/spring-cloud/spring-cloud-function/blob/{branch}/spring-cloud-function-samples/function-sample-azure/pom.xml[here].

NOTE: As of yet, only Maven plugin is available. Gradle plugin has not been created by
the cloud platform provider.

==== Build

----
./mvnw -U clean package
----

==== Running the sample

You can run the sample locally, just like the other Spring Cloud Function samples:

---
./mvnw spring-boot:run
---

and `curl -H "Content-Type: text/plain" localhost:8080/api/uppercase -d '{"value": "hello foobar"}'`.

You will need the `az` CLI app (see https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-java-maven for more detail). To deploy the function on Azure runtime:

----
$ az login
$ mvn azure-functions:deploy
----

On another terminal try this: `curl https://<azure-function-url-from-the-log>/api/uppercase -d '{"value": "hello foobar!"}'`. Please ensure that you use the right URL for the function above. Alternatively you can test the function in the Azure Dashboard UI (click on the function name, go to the right hand side and click "Test" and to the bottom right, "Run").

The input type for the function in the Azure sample is a Foo with a single property called "value". So you need this to test it with something like below:

----
{
  "value": "foobar"
}
----

NOTE: The Azure sample app is written in the "non-functional" style (using `@Bean`). The functional style (with just `Function` or `ApplicationContextInitializer`) is much faster on startup in Azure than the traditional `@Bean` style, so if you don't need `@Beans` (or `@EnableAutoConfiguration`) it's a good choice. Warm starts are not affected.
